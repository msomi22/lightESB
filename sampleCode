/**
 * 
 */
package demo;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.StringReader;
import java.util.*;

import javax.xml.parsers.*;
import javax.xml.xpath.*;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringSubstitutor;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

/**
 * 
 *
 */
public class DemoApp {

	static String transformationData1 = "UCASE,0";

	/**
	 * 
	 */
	public DemoApp() {

	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		// TODO
		Map<String, String> transformationMap = new HashMap<>();
		transformationMap.put("reference", extractXpath(callerRequest, "//reference"));
		transformationMap.put("customerName", extractXpath(callerRequest, "//customerName"));
		transformationMap.put("customerMobile", extractXpath(callerRequest, "//customerMobile"));
		transformationMap.put("systemCode", extractXpath(callerRequest, "//systemCode"));
		transformationMap.put("service", extractXpath(callerRequest, "//service"));

		String output = "STR";
		String outType = "MAP_LIST";
		String[] targetTags = { "id", "name", "mobile", "email", "balance" };
		String transformAttributes = "";// ADD_INDEX_AFTER,ADD_INDEX_BEFORE,ADD_INDEX_START,INDEX_BETWEEN

		Object out = transformXML(output, callerRequest, strTemplate, childTemplate3, outType, targetTags,
				transformationMap, transformAttributes);
		System.out.println(out.toString());

	}

	/**
	 * 
	 * @param outMessage
	 * @param callerRequest
	 * @param strTemplate
	 * @param childTemplate
	 * @param outType
	 * @param targetTags
	 * @param transformationMap
	 * @return
	 */
	public static Object transformXML(String outMessage, String callerRequest, String strTemplate, String childTemplate,
			String outType, String[] targetTags, Map<String, String> transformationMap, String transformAttributes) {

		Object outputMessage = "";
		switch (outMessage) {
		case "STR":

			outputMessage = toSTR(callerRequest, strTemplate, childTemplate, outType, targetTags, transformationMap,
					transformAttributes);
			break;

		default:
			break;
		}

		return outputMessage;
	}

	/**
	 * 
	 * @param callerRequest
	 * @param strTemplate
	 * @param childTemplate
	 * @param outType
	 * @param targetTags
	 * @param transformationMap
	 * @return
	 */
	private static Object toSTR(String callerRequest, String strTemplate, String childTemplate, String outType,
			String[] targetTags, Map<String, String> transformationMap, String transformAttributes) {
		String filtered = "";
		if (strTemplate.contains("*")) {
			strTemplate = StringUtils.replace(strTemplate, "*", "");
			filtered = getChildRecord(callerRequest, childTemplate, outType, targetTags, transformAttributes);
		}
		transformationMap.put("childTemplate", filtered);
		// TODO
		String transformationData = transformationData1;
		transformationMap = transformFields(transformationMap, "0", transformationData);// 0 = main template
		String output = replaceTemplate(strTemplate, transformationMap);

		return output;
	}

	/**
	 * 
	 * @param callerRequest
	 * @param childTemplate
	 * @param outType
	 * @param targetTags
	 * @return
	 */
	private static String getChildRecord(String callerRequest, String childTemplate, String outType,
			String[] targetTags, String transformAttributes) {
		String targetTag = StringUtils.substringBetween(childTemplate, "=", "[");
		targetTag = StringUtils.substringAfter(targetTag, "=");
		String wrapper = StringUtils.substringBefore(childTemplate, "=");
		Object outputMap = extractList(callerRequest, targetTag, targetTags, outType);
		String filtered = mapListFilter(outputMap, targetTags, childTemplate, wrapper, transformAttributes);
		return filtered;
	}

	/**
	 * 
	 * @param outputMap
	 * @param targetTags
	 * @param template
	 * @return
	 */
	private static String mapListFilter(Object outputMap, String[] targetTags, String template, String wrapper,
			String transformAttributes) {
		String delim = "";
		delim = StringUtils.substringBetween(template, "=", "=");
		template = StringUtils.substringBetween(template, "[", "]");
		String records = "";

		if (outputMap instanceof List) {
			@SuppressWarnings("unchecked")
			List<Map<String, String>> mapList = (List<Map<String, String>>) outputMap;
			int count = 1;
			for (Map<String, String> map : mapList) {
				String record = "";
				for (int i = 0; i < targetTags.length; i++) {
					// TODO
					String transformationData = transformationData1;
					map = transformFields(map, "1", transformationData);// secondary map, child
					record = replaceTemplate(template, map);
				}

				if (!transformAttributes.isEmpty()) {
					record = transformOutput(count, record, transformAttributes);
				}

				switch (delim) {
				case "XML":
					records += "<" + wrapper + ">" + record + "</" + wrapper + ">";
					break;
				case "JSON":
					if (count < mapList.size()) {
						records += record + ",";
					} else {
						records += record;
					}
					break;
				default:
					records += delim + "" + record;
					break;
				}
				count++;
			}
		}
		if (delim.equals("JSON")) {
			records = "{\"" + wrapper + "\":[" + records + "]}";
		}
		if (records.startsWith(delim)) {
			records = StringUtils.stripStart(records, delim);
		}

		return records;
	}

	/**
	 * 
	 * @param template
	 * @param map
	 * @param transformAttributes
	 * @param index
	 * @return
	 */
	private static String replaceTemplate(String template, Map<String, String> map) {
		String record = "";
		// map = transformFields(map);
		StringSubstitutor sub = new StringSubstitutor(map);
		record = sub.replace(template);
		return record;
	}

	/**
	 * TODO
	 * 
	 * @param map
	 * @return
	 */
	private static Map<String, String> transformFields(Map<String, String> map, String sourceMap,
			String transformationData) {
		Map<String, String> transformed = new HashMap<>();
		// Map<String, Object> inPutData = new HashMap<>();
		map.entrySet().stream().forEach(e -> {
			//System.out.println("key: " + e.getKey() + " value: " + e.getValue() + " sourceMap: " + sourceMap);
			String valueString = transformField(e.getValue(), map, transformationData);
			//System.out.println("valueString: " + valueString + " " + transformationData);
			transformed.put(e.getKey(), valueString);
		});
		return transformed;
	}

	/**
	 * 
	 * @param value
	 * @param inPutData
	 * @return
	 */
	private static String transformField(String value, Map<String, String> inPutData, String transformationData) {

		if (!transformationData.isEmpty()) {
			if (transformationData.contains(",")) {
				String[] parts = transformationData.split("\\,");
				String stripChars = "";
				switch (parts[0]) {
				case "JOIN":
					String joinWith = "";
					String joinChar = "";
					try {
						joinWith = parts[1];
						joinChar = parts[2];
						joinWith = inPutData.getOrDefault(joinWith, "");
					} catch (Exception e) {

					}
					value = value + joinChar + joinWith;
					break;
				case "STRIPSTART":
					try {
						stripChars = parts[1];
					} catch (Exception e) {

					}
					value = StringUtils.stripStart(value, stripChars);
					break;
				case "STRIPEND":
					try {
						stripChars = parts[1];
					} catch (Exception e) {

					}
					value = StringUtils.stripEnd(value, stripChars);
					break;
				case "UCASE":
					value = value.toUpperCase();
					break;
				case "LCASE":
					value = value.toLowerCase();
					break;
				case "DATE_FORMART":
					break;
				case "CONST":
					String constant = "";
					try {
						constant = parts[1];
					} catch (Exception e) {

					}
					value = constant;
					break;
				default:
					break;

				}
			}
		}

		return value;
	}

	private static String transformOutput(int count, String output, String transformAttributes) {
		if (transformAttributes.contains(",")) {
			String[] transformPart = transformAttributes.split("\\,");
			String transform = transformPart[0];
			String literal = transformPart[1];
			String[] parts = output.split("\\,");
			for (String part : parts) {
				try {
					int charIndex = part.indexOf(literal);
					String part1 = part.substring(0, charIndex + 1);
					String part11 = part.substring(0, charIndex);
					String replacement = "";
					switch (transform) {
					case "ADD_INDEX_AFTER":
						replacement = part11 + literal + count;
						if (!output.contains(replacement)) {
							output = StringUtils.replace(output, part1, replacement);
						}
						break;
					case "ADD_INDEX_BEFORE":
						replacement = part11 + count + literal;
						output = StringUtils.replace(output, part1, replacement);
						break;
					case "ADD_INDEX_START":
						replacement = count + part;
						output = StringUtils.replace(output, part, replacement);
						break;
					case "INDEX_BETWEEN":
						String between = "";
						replacement = count + "";
						// System.out.println("transformAttributes " + transformAttributes.part);
						if (transformPart.length == 3) {
							between = StringUtils.substringBetween(part, transformPart[1], transformPart[2]);
							output = StringUtils.replace(output, between, replacement);
						} else if (transformPart.length == 2) {
							between = StringUtils.substringBetween(part, literal, literal);
							output = StringUtils.replace(output, between, replacement);
						}

						break;
					default:
						break;
					}
				} catch (Exception e) {

				}
			}
		}
		return output;
	}

	/**
	 * 
	 * @param xmlInput
	 * @param path
	 * @return
	 */
	private static String extractXpath(String xmlInput, String path) {
		try {
			XPath xPath = XPathFactory.newInstance().newXPath();
			XPathExpression query = xPath.compile(path);
			return query.evaluate(new InputSource(new StringReader(xmlInput)));
		} catch (Exception e) {

		}
		return "";
	}

	/**
	 * 
	 * @param inputXML
	 * @return
	 */
	private static Document getXMLDocument(String inputXML) {
		Document document = null;
		try {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();

			InputStream is = new ByteArrayInputStream(inputXML.getBytes());

			document = builder.parse(is);
		} catch (Exception e) {
			e.printStackTrace();
		}
		document.getDocumentElement().normalize();
		return document;
	}

	/**
	 * 
	 * @param targetTags
	 * @param listName
	 * @param listItem
	 * @param outputObject
	 * @param inputsTags
	 * @return
	 */
	private static Object extractList(String callerRequest, String targetTag, String[] targetTags, String outType) {
		Object out = new Object();
		switch (outType) {

		case "MAP_LIST":
			Document document = getXMLDocument(callerRequest);

			// Element root = document.getDocumentElement();
			// System.out.println("root: " + root.getNodeName());
			// get list
			NodeList nList = document.getElementsByTagName(targetTag);
			// System.out.println("targetTag: " + targetTag);

			List<Map<String, String>> mapList = new ArrayList<Map<String, String>>();
			for (int temp = 0; temp < nList.getLength(); temp++) {
				Node node = nList.item(temp);
				if (node.getNodeType() == Node.ELEMENT_NODE) {
					Element eElement = (Element) node;
					String value = "";
					Map<String, String> map = new HashMap<>();
					for (String tagName : targetTags) {
						if (eElement.getElementsByTagName(tagName) != null) {
							value = eElement.getElementsByTagName(tagName).item(0).getTextContent();
							map.put(tagName, value);
						} else {
							System.err.println("Tag  " + tagName + " not found");
						}

					}
					mapList.add(map);
					// System.out.println(eElement.getAttribute("id"));
					// System.out.println(eElement.getElementsByTagName("firstName").item(0).getTextContent());
				}
			}

			out = mapList;
			break;

		default:
			break;

		}

		return out;
	}

	static String callerRequest = "<request>\n" + "    <header>\n" + "        <systemCode>100</systemCode>\n"
			+ "        <timestamp>time_here</timestamp>\n" + "        <service>001</service>\n" + "    </header>\n"
			+ "    <body>\n" + "        <reference>unique_id</reference>\n"
			+ "        <customerName>Peter Mwenda</customerName>\n"
			+ "        <customerMobile>0718953974</customerMobile>\n" + "        <accounts>\n"
			+ "            <account>\n" + "                <id>1</id>\n" + "                <name>peter</name>\n"
			+ "                <mobile>0718953974</mobile>\n"
			+ "                <email>mwendapeter72@gmail.com</email>\n" + "                <balance>100</balance>\n"
			+ "            </account>\n" + "             <account>\n" + "                <id>2</id>\n"
			+ "                <name>peter</name>\n" + "                <mobile>0718953974</mobile>\n"
			+ "                <email>mwendapeter72@gmail.com</email>\n" + "                <balance>100</balance>\n"
			+ "            </account>\n" + "             <account>\n" + "                <id>3</id>\n"
			+ "                <name>peter</name>\n" + "                <mobile>0718953974</mobile>\n"
			+ "                <email>mwendapeter72@gmail.com</email>\n" + "                <balance>100</balance>\n"
			+ "            </account>\n" + "        </accounts>\n" + "    </body>\n" + "</request>";

	static String ackTemplate = "<response>\n" + "    <header>\n" + "        <systemCode>${systemCode}</systemCode>\n"
			+ "        <timestamp>${currentTime}</timestamp>\n" + "        <service>${service}</service>\n"
			+ "    </header>\n" + "    <body>\n" + "        <reference>${reference}</reference>\n"
			+ "        <satus>${responseCode}</satus>\n" + "        <statusDesc>${ResponseDesc}</statusDesc>\n"
			+ "    </body>\n" + "</response>";

	static String strTemplate = "REQUEST:REF=${reference},NAME=${customerName},MOBILE=${customerMobile},ACCOUNTS=*${childTemplate}";

	static String childTemplate = "account=^=account[ACCOUNT_NO:=${id},ACCOUNT_TITLE:=${name},ACCOUNT_MOBILE:=${mobile},ACCOUNT_EMAIL:=${email},ACCOUNT_BALANCE:=${balance}]";
	static String childTemplate2 = "account=XML=account[<acountNo>${id}</acountNo><accountTitle>${name}</accountTitle><accountMobile>${mobile}</accountMobile><accountEmail>${email}</accountEmail><accountBalance>${balance}</accountBalance>]";
	static String childTemplate3 = "account=JSON=account[{\"response\":{\"acountNo\":\"${id}\",\"accountTitle\":\"${name},\",\"accountMobile\":\"${mobile}\",\"accountEmail\":\"${email}\",\"accountBalance\":\"${balance}\"}}]";
	static String finalResponseTemplate = "{\n" + "	\"statusCode\": \"${responseCode}\",\n"
			+ "	\"statusDesc\": \"${ResponseDesc}\",\n" + "	\"response\": [{\n"
			+ "			\"ResponseString\": \"${template}\",\n" + "			\"status\": \"${ResponseDesc}\"\n"
			+ "		}\n" + "\n" + "	]\n" + "}\n";
}
